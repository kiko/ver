# Encoding: UTF-8

[{beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n$: << ENV['TM_SUPPORT_PATH'] + '/lib'\nrequire 'escape'\ndef esc(str)\n  e_sn(str).gsub(/\\}/, '\\\\}') # escaping inside a placeholder\nend\n\ns = STDIN.read\nif s.empty? then\n  print \"**$1**\"\nelsif s =~ /^\\*{2}(.*)\\*{2}$/ then\n  print \"${1:\#{esc $1}}\"\nelsif ENV.has_key? 'TM_SELECTED_TEXT'\n  print \"${1:**\#{esc s}**}\"\nelse\n  print \"**\#{e_sn s}**\"\nend",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@b",
  name: "Bold",
  output: "insertAsSnippet",
  scope: "text.html.markdown -meta.disable-markdown",
  uuid: "31614C02-1FED-4644-9518-2C2DEF0D7A2C"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_BUNDLE_SUPPORT']\n$: << ENV['TM_SUPPORT_PATH']\n\nrequire 'lib/markdown'\nrequire 'lib/escape'\n\n# get the list itself\nlisttxt = $stdin.read()\nlist = Markdown::List.parse(listtxt)\n\n# now we need to figure out where we were when we hit enter\noffsetline = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i()\nindex = ENV['TM_LINE_INDEX'].to_i()\n\nlist.get_entry(offsetline) do |e, l, n|\n\tl.numbered = !l.numbered\nend\nprint list.to_s()\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^*",
  name: "Change Style",
  output: "replaceSelectedText",
  scope: "text.html.markdown markup.list",
  uuid: "39A74FF2-46EF-4178-9E3A-7D4DB3968E05"},
 {beforeRunningCommand: "nop",
  command: 
   "InsertFormatHeader.rb|MultiMarkdown.pl|\"${TM_SMARTYPANTS:-SmartyPants.pl}\"",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^H",
  name: "Convert Document / Selection to HTML",
  output: "openAsNewDocument",
  scope: "text.html.markdown.multimarkdown",
  uuid: "9F73CBC1-E9C0-41A4-891F-B2879A1852F7"},
 {beforeRunningCommand: "nop",
  command: 
   "# This command works well when you use the TextMate service from a \n# web-log editor like Ecto or MarsEdit.  You can write in markdown\n# and then convert back to html before save and close.\n\nHTML4=$([ -n \"$TM_XHTML\" ] || echo '--html4tags')\n\"${TM_MARKDOWN:-Markdown.pl}\" $HTML4|\"${TM_SMARTYPANTS:-SmartyPants.pl}\"|perl -pe '\n\t# make <h1>Header</h1> into <h1 id=\"header\">Header</h1>\n\t# so that we can link to page#header\n\tif(($tag, $title) = /<(h[1-6])>(.*?)<\\/\\1>/) {\n\t\t$_ = $title;\n\t\ts/<[^>]+>|&\\w+;//g;\t# remove tag and entities\n\t\ts/[^-_ \\/\\w]//g;\t\t# remove all but word and separators\n\t\ts/[-_ \\/]+/_/g;\t\t# collapse all separators into _\n\t\t$_ = \"<$tag id=\\\"\" . (lc $_) . \"\\\">$title</$tag>\\n\";\n\t}'\n",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^H",
  name: "Convert Document / Selection to HTML",
  output: "replaceSelectedText",
  scope: "text.html.markdown",
  uuid: "966B0E57-799A-4B91-84B4-75695A78F7B8"},
 {beforeRunningCommand: "nop",
  command: 
   "InsertFormatHeader.rb|MultiMarkdown.pl|SmartyPants.pl|xsltproc -novalid -nonet \"$TM_BUNDLE_SUPPORT/xhtml2article.xslt\"  -",
  fallbackInput: "document",
  input: "selection",
  name: "Convert Document / Selection to LaTeX",
  output: "openAsNewDocument",
  scope: "text.html.markdown.multimarkdown",
  uuid: "67EB96A4-4213-42C9-9C47-B886A4B8AC93"},
 {beforeRunningCommand: "nop",
  command: 
   "InsertFormatHeader.rb|MultiMarkdown.pl|SmartyPants.pl|xsltproc -novalid -nonet \"$TM_BUNDLE_SUPPORT/xhtml2memoir.xslt\" -",
  fallbackInput: "document",
  input: "selection",
  name: "Convert Document / Selection to LaTeX (Memoir)",
  output: "openAsNewDocument",
  scope: "text.html.markdown.multimarkdown",
  uuid: "3BAE5ECF-9006-43D0-9AEB-28FAFE526840"},
 {beforeRunningCommand: "nop",
  command: 
   "# first figure out a name for the result\nNAME=\"${TM_FILENAME:-untitled}\"\nBASENAME=\"${NAME%.*}\"\nDST=\"/tmp/$BASENAME\"\n\nInsertFormatHeader.rb|MultiMarkdown.pl|SmartyPants.pl|\"${TM_RUBY:-ruby}\" >\"$DST.html\" -KU -pe '$_.gsub!(/[^\\x00-\\x7F]/) { |ch| \"&#\#{ch.unpack(\"U\")[0]};\" }'\n\n# show the generated HTML file\ncat \"$DST.html\"\n\n# convert to PDF with htmldoc\nrequire_cmd htmldoc\nhtmldoc -f \"$DST.pdf\" --header \"\" --footer \"\" --webpage \"$DST.html\"\n\n# open in the users PDF viewer (falling back on Preview)\nviewer=$(find_app \"${TM_PDF_VIEWER:-Preview.app}\")\nif [ $? = 0 ];\n\tthen open -a \"$viewer\" \"$DST.pdf\"\n\telse echo \"Could not find your PDF viewer: ‘${TM_PDF_VIEWER:-Preview.app}’\"\nfi\n",
  fallbackInput: "document",
  input: "selection",
  name: "Convert Document / Selection to PDF",
  output: "showAsHTML",
  scope: "text.html.markdown.multimarkdown",
  uuid: "DB5085DA-3E95-4020-8521-C9702168F160"},
 {beforeRunningCommand: "nop",
  command: 
   "# first figure out a name for the result\nNAME=\"${TM_FILENAME:-untitled}\"\nBASENAME=\"${NAME%.*}\"\nDST=\"/tmp/$BASENAME\"\n\nInsertFormatHeader.rb|MultiMarkdown.pl|SmartyPants.pl >\"$DST.html\"\n\n# textutil is included with Tiger\nrequire_cmd textutil\ntextutil -convert rtf -extension rtf -font Times -fontsize 11 \"$DST.html\"\n\nopen -a TextEdit.app \"$DST.rtf\"\n",
  fallbackInput: "document",
  input: "selection",
  name: "Convert Document / Selection to RTF",
  output: "discard",
  scope: "text.html.markdown.multimarkdown",
  uuid: "D9118E94-4E23-4B75-88D7-6BFEBAA70D1B"},
 {beforeRunningCommand: "nop",
  command: 
   "MultiMarkdown.pl|\"${TM_SMARTYPANTS:-SmartyPants.pl}\" > \"${TM_DIRECTORY:-/tmp}\"/output.html\nopen \"${TM_DIRECTORY:-/tmp}\"/output.html",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^@p",
  name: "Generate Output and Open in Browser",
  output: "discard",
  scope: "text.html.markdown.multimarkdown",
  uuid: "351451DE-C1A4-4A36-A563-99AF761D026B"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n$: << ENV['TM_SUPPORT_PATH'] + '/lib'\nrequire 'escape'\ndef esc(str)\n  e_sn(str).gsub(/\\}/, '\\\\}') # escaping inside a placeholder\nend\n\ns = STDIN.read\nif s.empty? then\n  print \"*$1*\"\nelsif s =~ /^(\\*+)(.*[^\\*])\\*+$/ then\n  m, s = $1, $2\n  case m.length\n    when 1 then print \"${1:\#{esc s}}\"\n    when 2 then print \"${1:***\#{esc s}***}\"\n    else print \"${1:**\#{esc s}**}\"\n  end\nelsif ENV.has_key? 'TM_SELECTED_TEXT'\n  print \"${1:*\#{esc s}*}\"\nelse\n  print \"*\#{e_sn s}*\"\nend",
  fallbackInput: "word",
  input: "selection",
  keyEquivalent: "@i",
  name: "Italic",
  output: "insertAsSnippet",
  scope: "text.html.markdown -meta.disable-markdown",
  uuid: "F56525A1-C879-4A7C-9584-4DB28AFC58C2"},
 {beforeRunningCommand: "nop",
  captureFormatString: "$3",
  capturePattern: "^([^:]*):([^:]*):(.*)$",
  command: 
   "#!/usr/bin/env ruby -wKU\n\nrequire 'jcode'\n\n# Split document into lines. Get current line number minus one for\n# previous, minus another for ruby being 0 based.\nlines = STDIN.readlines\nline  = ENV['TM_LINE_NUMBER'].to_i - 2\n\n# Get length of previous line, using jlength for unicode\nlength = lines[line].rstrip.jlength\n\n# Print same number of =\nlength.times { print \"=\" }\n",
  fileCaptureRegister: "1",
  input: "document",
  lineCaptureRegister: "2",
  name: "Level 1 [setext]",
  output: "afterSelectedText",
  scope: "text.html.markdown",
  tabTrigger: "=",
  uuid: "F3A754C3-CE6B-11D9-9C17-000A95C0F626"},
 {beforeRunningCommand: "nop",
  captureFormatString: "$3",
  capturePattern: "^([^:]*):([^:]*):(.*)$",
  command: 
   "#!/usr/bin/env ruby -wKU\n\nrequire 'jcode'\n\n# Split document into lines. Get current line number minus one for\n# previous, minus another for ruby being 0 based.\nlines = STDIN.readlines\nline  = ENV['TM_LINE_NUMBER'].to_i - 2\n\n# Get length of previous line, using jlength for unicode\nlength = lines[line].rstrip.jlength\n\n# Print same number of -\nlength.times { print \"-\" }\n",
  fileCaptureRegister: "1",
  input: "document",
  lineCaptureRegister: "2",
  name: "Level 2 [setext]",
  output: "afterSelectedText",
  scope: "text.html.markdown",
  tabTrigger: "-",
  uuid: "724FCFF6-CE6B-11D9-9C17-000A95C0F626"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_BUNDLE_SUPPORT']\n$: << ENV['TM_SUPPORT_PATH']\n\nrequire 'lib/markdown'\nrequire 'lib/escape'\n\n# get the list itself\nlisttxt = $stdin.read()\nlist = Markdown::List.parse(listtxt)\n\n# now we need to figure out where we were when we hit enter\noffsetline = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i()\nindex = ENV['TM_LINE_INDEX'].to_i()\n\nlist.break(offsetline, index) { |l| e_sn(l) }\nprint list.to_s()\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "",
  name: "New Item",
  output: "insertAsSnippet",
  scope: "text.html.markdown markup.list",
  uuid: "622F0B69-EB98-4EB9-8DC8-2AC56FF2501E"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_BUNDLE_SUPPORT']\n$: << ENV['TM_SUPPORT_PATH']\n\nrequire 'lib/markdown'\nrequire 'lib/escape'\n\n# get the list itself\nlisttxt = $stdin.read()\nlist = Markdown::List.parse(listtxt)\n\n# now we need to figure out where we were when we hit enter\noffsetline = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i()\nindex = ENV['TM_LINE_INDEX'].to_i()\n\nlist.break(offsetline, index, \"$0\", true) { |l| e_sn(l) }\nprint list.to_s()\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "$",
  name: "New Subitem",
  output: "insertAsSnippet",
  scope: "text.html.markdown markup.list",
  uuid: "000B399B-FB71-49EF-B799-A1200A3865AB"},
 {beforeRunningCommand: "nop",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"Markdown Preview\" \"${TM_FILENAME:-}\"\n\nif [[ -f \"$TM_FILEPATH\" ]]; then\n  echo \"<base href='tm-file://${TM_FILEPATH// /%20}'>\"\nfi\n\n# Convert to html then make one of the html tags above caret \n# into a link that we scroll down to\n\"${TM_MARKDOWN:-Markdown.pl}\"|\"${TM_SMARTYPANTS:-SmartyPants.pl}\"|${TM_RUBY:-ruby} -e '\nlines = STDIN.read.split(\"\\n\")\nn = [ENV[\"TM_LINE_NUMBER\"].to_i, lines.length].min - 7\n\nwhile n > 0 && !lines[n].match(/<(h\\d|p|ul|li|blockquote|pre|div|img|code|table|tr)>/i)\n  n -= 1\nend\n\nif n > 0 && m = lines[n].match(/<(h\\d|p|ul|li|blockquote|pre|div|img|code|table|tr)>(.*)$/i)\n  lines[n] = \"<\#{m[1]} id=\\\"scroll_to_here\\\" >\#{m[2]}\"\nend\n\nputs lines.join(\"\\n\")\nputs \"\\n<script>window.location.hash = \\\"scroll_to_here\\\";</script>\"\n'\nhtml_footer",
  input: "document",
  keyEquivalent: "^~@p",
  name: "Preview",
  output: "showAsHTML",
  scope: "text.html.markdown",
  uuid: "B52DEA16-8480-11D9-BE59-000D93B3A10E"},
 {beforeRunningCommand: "nop",
  bundleUUID: "D99E8C0C-792F-11D9-A212-000D93B3A10E",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\n\nif [[ -z $TM_FILENAME ]]\n  then title=\"Markdown as HTML\"\n  else title=\"${TM_FILENAME%.*}\"\nfi\n\nhtml_header \"$title\" \"MultiMarkdown\"\n\nif [[ -f \"$TM_FILEPATH\" ]]; then\n  echo \"<base href='tm-file://${TM_FILEPATH// /%20}'>\"\nfi\n\nMultiMarkdown.pl|\"${TM_SMARTYPANTS:-SmartyPants.pl}\"\nhtml_footer",
  fallbackInput: "document",
  input: "selection",
  keyEquivalent: "^~@p",
  name: "Preview",
  output: "showAsHTML",
  scope: "text.html.markdown.multimarkdown",
  uuid: "7CCF064C-BC8F-437B-A339-0E2156D8B2C3"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_BUNDLE_SUPPORT']\n$: << ENV['TM_SUPPORT_PATH']\n\nrequire 'lib/markdown'\nrequire 'lib/escape'\n\n# get the list itself\nlisttxt = $stdin.read()\nlist = Markdown::List.parse(listtxt)\n\nprint list.to_s()\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "^{",
  name: "Reformat",
  output: "replaceSelectedText",
  scope: "text.html.markdown markup.list",
  uuid: "5EFA9FF4-2246-4AF4-ABD6-2B7ADB4E9B80"},
 {beforeRunningCommand: "nop",
  command: 
   "#!/usr/bin/env ruby\n\n$: << ENV['TM_BUNDLE_SUPPORT']\n$: << ENV['TM_SUPPORT_PATH']\n\nrequire 'lib/markdown'\nrequire 'lib/escape'\n\n# get the list itself\nlisttxt = $stdin.read()\nlist = Markdown::List.parse(listtxt)\n\n# now we need to figure out where we were when we hit enter\noffsetline = ENV['TM_LINE_NUMBER'].to_i() - ENV['TM_INPUT_START_LINE'].to_i()\nindex = ENV['TM_LINE_INDEX'].to_i()\n\nlist.select(offsetline) { |l| e_sn(l) }\nprint list.to_s()\n",
  fallbackInput: "scope",
  input: "selection",
  keyEquivalent: "@",
  name: "Select Item",
  output: "insertAsSnippet",
  scope: "text.html.markdown markup.list",
  uuid: "ADEF8E57-BF21-487A-9115-E1D1146142CD"},
 {beforeRunningCommand: "nop",
  bundleUUID: "D99E8C0C-792F-11D9-A212-000D93B3A10E",
  command: 
   ". \"$TM_SUPPORT_PATH/lib/webpreview.sh\"\nhtml_header \"Markdown Cheat Sheet\"\nMarkdown.pl \"$TM_BUNDLE_SUPPORT/help.markdown\"\nhtml_footer",
  input: "none",
  keyEquivalent: "^h",
  name: "Syntax Cheat Sheet",
  output: "showAsHTML",
  scope: "text.html.markdown",
  uuid: "FE31CF79-5F04-4FB6-B5CE-70BC781FF8B5"}]
